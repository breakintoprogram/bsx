; Defines
;
ROM_START		EQU 	0x0000			
RAM_START		EQU 	0x8000

SYS_VARS		EQU	RAM_START		; System variable block
SYS_VARS_RAMTOP		EQU 	RAM_START + 0x00
SYS_VARS_INPUT		EQU	RAM_START + 0x02

PORT_STM_IO 		EQU	0x00			; The IO port for serial terminal IO
PORT_STM_DIAG		EQU	0x07			; Diagnostics port - not used yet

BUILD_ROM		EQU 	0			; Set to 1 to build for ROM, or 0 to build for RAM
SKIP_MEMTEST		EQU	1			; Set to 1 to skip the memtest on boot - leave this until proper clock fitted

			IF BUILD_ROM = 0
			ORG 0x8200
			ELSE
			ORG ROM_START
;
; RST 00
;
			DI
			JP Start
			DS 4
;
; RST 08 - Output char to STM32
;
			DS 8
;
; RST 10
;
			DS 8
;
; RST 18
;
			DS 8
;
; RST 20
; 
			DS 8
;
; RST 28
;
			DS 8
;
; RST 30
;
			DS 8
;
; RST 38 - NMI
;
			EI
			RET

			ENDIF 
;
; Start
;
Start:			IF SKIP_MEMTEST = 1
			LD HL,0x0000
			XOR A 
			JR 3F 
			ENDIF
			LD HL,RAM_START
			LD C,0b10101010
1:			LD (HL),C
			LD A,(HL)
			CP C
			JR NZ,3F
			INC HL
			LD A,L
			OR A
			JR NZ,2F
			LD A,"."
			OUT (PORT_STM_IO),A 
2:			LD A,H
			OR A
			JR NZ,1B
3:			LD (SYS_VARS_RAMTOP),HL		; Store last byte of physical RAM in the system variables
			LD SP,HL			; Set the stack pointer
			JR Z,Memtest_OK
			LD HL,MSG_BADRAM
			JR Ready
Memtest_OK:		LD HL,MSG_READY

Ready:			PUSH HL
			LD HL,MSG_STARTUP
			CALL Print_String
			POP HL
			CALL Print_String

Input:			LD HL,SYS_VARS_INPUT		; Input buffer
			ld B,0				; Cursor position
Input_Loop:		IN A,(PORT_STM_IO)		; Read a key from the keyboard
			OR A				; Check for zero
			JR Z,Input_Loop			; Loop - no key input yet

			CALL Print_Char			; Output the character

			CP 0x7F: JR Z,Input_Backspace	; Handle backspace

			LD (HL),A			; Store the character in the buffer
			INC HL				; Increment to next character in buffer
			INC B 				; Increment the cursor position
			CP 0x0D				; Check for newline
			JR NZ,Input_Loop		; If not pressed, then loop

			CALL Print_CR			; Output a carriage return

			LD A,(SYS_VARS_INPUT)		; Check the first character of input
			LD HL,Input_Ret			; Push the return address on the stack
			PUSH HL
			CP 'M': JP Z,FN_Memory_Dump
			CP 'L': JP Z,FN_Memory_Load
			CP 'J': JP Z,FN_Jump
			POP HL				; Not jumped to anything, so pop the return address off the stack

Input_Ret:		CALL Print_CR			; On return from the function, print a carriage return
			LD HL,MSG_READY			; And the ready message
			CALL Print_String 
			JR Input 			; Loop around for next input line

Input_Backspace:	LD A,B				; Are we on the first character?
			OR A 
			JR Z,Input_Loop
			DEC HL				; Skip back in the buffer
			DEC B
			LD (HL),0
			JR Input_Loop

FN_Jump:		LD HL,SYS_VARS_INPUT+1
			CALL Parse_Hex16
			EX DE,HL
			JP (HL)

FN_Memory_Load:		IN A,(PORT_STM_IO): LD L,A
			IN A,(PORT_STM_IO): LD H,A 
			IN A,(PORT_STM_IO): LD C,A 
			IN A,(PORT_STM_IO): LD B,A 
1:			IN A,(PORT_STM_IO)
			LD (HL),A
			INC HL
			DEC BC
			LD A,B 
			OR C
			JR NZ,1B
			RET 

FN_Memory_Dump:		LD HL,SYS_VARS_INPUT+1
			CALL Parse_Hex16
			LD A,(HL)
			CP ','
			JR NZ,2F
			INC HL
			PUSH DE
			CALL Parse_Hex16
			POP HL 
			LD A,D 
			OR E 
			JP NZ,Memory_Dump 
2:			LD HL,MSG_ERROR
			JP Print_String

; Print a zero terminated string to the terminal port
; HL: Address of the string
;
Print_String:		LD A,(HL)
			OR A
			RET Z
			CALL Print_Char
			INC HL
			JP Print_String 

; Dump some memory out
; HL: Start of memory to dump
; DE: Number of bytes to dump out
;
Memory_Dump:		CALL Print_Hex16
			LD A,':'
			CALL Print_Char
			LD A,' '
			CALL Print_Char
			LD B,16
1:			LD A,(HL)
			CALL Print_Hex8 
			INC HL
			DEC DE
			LD A,D
			OR E
			RET Z
			IN A,(PORT_STM_IO)
			CP 0x1B
			RET Z
			DJNZ 1B
			CALL Print_CR
			JR Memory_Dump

; Parse a hex string (up to 4 nibbles) to a binary
; HL: Address of hex (ASCII)
; DE: Output
;
Parse_Hex16:		LD DE,0			; Clear the output
1:			LD A,(HL)		; Get the nibble
			SUB '0'			; Normalise to 0
			RET C			; Return if < ASCII '0'
			CP 10			; Check if >= 10
			JR C,2F
			SUB 7			; Adjust ASCII A-F to nibble
			CP 16			; Check for > F
			RET NC			; Return
2:			SLA DE 			; Shfit DE left 4 times
			SLA DE 
			SLA DE
			SLA DE 
			OR E			; OR the nibble into E
			LD E,A 
			INC HL 			; Increase pointer to next byte of input
			JR 1B			; Loop around

; Print a 16-bit HEX number
; HL: Number to print
;
Print_Hex16:		LD A,H
			CALL Print_Hex8
			LD A,L

; Print an 8-bit HEX number
; A: Number to print
;
Print_Hex8:		LD C,A
			RRA 
			RRA 
			RRA 
			RRA 
			CALL 1F 
			LD A,C 
1:			AND 0x0F
			ADD A,0x90
			DAA
			ADC A,0x40
			DAA
			JR Print_Char 			

; Print CR/LF
;
Print_CR:		LD A,0x0D
			CALL Print_Char
			LD A,0x0A
			JR Print_Char

; Print a single character
; A: ASCII character
;
Print_Char:		OUT (PORT_STM_IO),A 
			RET 

; Messages
;
MSG_STARTUP:		DZ "BSX Version 0.1\n\r"
MSG_READY:		DZ "Ready\n\r"
MSG_BADRAM:		DZ "Mem Fault\n\r"
MSG_ERROR:		DZ "Error\n\r"

